#lang sicp
#| NOTE: We need to use a Doubly-Linked-List! |#

(define (make-deque)
  (let ((front-ptr '())
        (rear-ptr '()))
    (define (empty-deque?) (null? front-ptr))
    (define (front-deque)
      (if (empty-deque?)
          (error "FRONT called with an empty deque")
          (caar front-ptr)))
     (define (rear-deque)
      (if (empty-deque?)
          (error "REAR called with an empty deque")
          (caar rear-ptr)))
    (define (front-insert-deque! v)
      (let ((new-pair (cons (cons v '()) front-ptr) ))
        (cond ((empty-deque?)
               (set! front-ptr new-pair)
               (set! rear-ptr new-pair))
              (else
               (set-cdr! (car front-ptr) new-pair)
               (set! front-ptr new-pair)))))
    (define (rear-insert-deque! v)
      (let ((new-pair (cons (cons v rear-ptr) '()) ))
        (cond ((empty-deque?)
               (set! front-ptr new-pair)
               (set! rear-ptr new-pair))
              (else
               (set-cdr! rear-ptr new-pair)
               (set! rear-ptr new-pair)))))
    (define (front-delete-deque!)
      (cond ((empty-deque?)
             (error "FRONT DELETE! called with an empty deque"))
            (else
             (let ((new-front (cdr front-ptr)))
               (if (null? (cdr front-ptr))
                   (set! front-ptr '())
                   (begin
                    (set-cdr! (car new-front) '())
                    (set! front-ptr new-front))
               )))))
    (define (rear-delete-deque!)
      (cond ((empty-deque?)
             (error "REAR DELETE! called with an empty deque"))
            (else
             (let ((new-rear (cdar rear-ptr)))
               (if (null? (cdr front-ptr))
                   (set! front-ptr '())
                   (begin
                     (set-cdr! new-rear '())
                     (set! rear-ptr new-rear))
               )))))
    (define (dispatch m)
      (cond
        ((eq? m 'empty-deque?) (empty-deque?))
        ((eq? m 'front-deque) (front-deque))
        ((eq? m 'rear-deque) (rear-deque))
        ((eq? m 'front-insert-deque!) front-insert-deque!)
        ((eq? m 'rear-insert-deque!) rear-insert-deque!)
        ((eq? m 'front-delete-deque!) (front-delete-deque!))
        ((eq? m 'rear-delete-deque!) (rear-delete-deque!))
        (else
         (error "Undefined operation: CONS" m))))
    dispatch))
(define (empty-deque? q) (q 'empty-deque?))
(define (front-deque q) (q 'front-deque))
(define (rear-deque q) (q 'rear-deque))
(define (front-insert-deque! q v) ((q 'front-insert-deque!) v))
(define (rear-insert-deque! q v) ((q 'rear-insert-deque!) v))
(define (front-delete-deque! q) (q 'front-delete-deque!))
(define (rear-delete-deque! q) (q 'rear-delete-deque!))

; Testing
(define q (make-deque))
(empty-deque? q)
(front-insert-deque! q 4)
(front-insert-deque! q 3)
(front-insert-deque! q 2)
(front-insert-deque! q 1)
(front-deque q)
(rear-deque q)
(front-delete-deque! q)
(front-delete-deque! q)
(front-delete-deque! q)
(front-delete-deque! q)
(front-deque q)
(rear-deque q)

